[列挙型の作り方を再考する](https://gocon.jp/2023/sessions/LT8/)

## 練習の題材

- 記号、区分値を持つ抽象: できれば3つ考えて `3C2 = 3` 通りの組み合わせの処理を考えてみる
    - Student: 学生
    - Subject: 科目
    - Textbook: 教科書
        - 学生 x 科目
            - 履修可能かどうか
            - 成績を算出する
        - 科目 x 教科書
- 実験すべきこと
    - visitor を追加する
    - acceptor を追加する
    - 大元の振舞を追加する

## 感想

- Go のインターフェース実装はダックタイピングだけど、非公開メソッドで定義するのは大抵不十分だと理解した
    - そのメソッドを直接参照していなくても、パッケージ外だとメソッドを実装したと見做されないっぽい
- Visitor パターンというけど、中心となるのは Acceptor だと思った
    - Go でパッケージの循環参照を避けようと思うと、インターフェースは Acceptor のパッケージに寄せる必要がある
    - Acceptor は変更が入りにくいものを選んで設計したい
    - Acceptor のインターフェースは抽象だけにすることが出来る
        - 対して Visitor は Acceptor の具象を参照する
    - 外部レイヤーが参照するのは Acceptor の振舞（多分）

---

[ダブル・ディスパッチ～ 典型的なオブジェクト指向プログラミング・イディオム ～](https://www.infoq.com/jp/articles/DoubleDispatch_0829/)

記事中における Item が Acceptor で Member が Visitor に相当する。
Member が増えたときは、Member 側の具象を増やすだけで良いため、変更箇所は少ない。
Visit 側が増えたときは、Visitor の具象が1つ増えるのに加えて、Member の振舞が1つと Member の具象それぞれで振舞を追加する必要がある。
このため、 **種類が増えやすいほうを Visitor 側にする設計のほうが良い** 、と言う見方が出来る。

処理フローとしては `outer layer -> acceptor -> visitor` という感じなので、中間が増えるほうが面倒臭いという感じ。

